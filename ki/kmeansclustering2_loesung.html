
<!DOCTYPE html>


<html lang="de" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>22.9. Programmierung des Algorithmus (L√∂sung) &#8212; Datenstrukturen und KI</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../_static/thebe.css?v=9bca0c2f" />
    <link rel="stylesheet" type="text/css" href="../_static/code.css?v=4bf7ba55" />
    <link rel="stylesheet" type="text/css" href="../_static/tippy.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../_static/tippy_custom.css?v=eb815f20" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../_static/documentation_options.js?v=91fba89f"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
    <script src="../_static/translations.js?v=79cc9f76"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script defer="defer" src="../_static/refresh.js?v=9bea9b76"></script>
    <script>const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script defer="defer" src="../_static/sphinx-thebe-lite.js?v=2a71eeb1"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script src="https://unpkg.com/@popperjs/core@2"></script>
    <script src="https://unpkg.com/tippy.js@6"></script>
    <script defer="defer" src="../_static/tippy/ki/kmeansclustering2_loesung.e53deaaa-410a-4615-ac5f-afd07b684929.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'ki/kmeansclustering2_loesung';</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../_static/dropdown-opener.js?v=628c8bad"></script>
    <link rel="canonical" href="¬†&#34;https://jil91.github.io/&#34;/ki/kmeansclustering2_loesung.html" />
    <link rel="icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Stichwortverzeichnis" href="../genindex.html" />
    <link rel="search" title="Suche" href="../search.html" />
    <link rel="next" title="23. Entscheidungsb√§ume lernen" href="entscheidungsbaumlernen.html" />
    <link rel="prev" title="22.8. Programmierung des Algorithmus" href="kmeansclustering2_aufgabe.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="de"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../intro.html">
  
  
  
  
  
  
    <p class="title logo__title">Datenstrukturen und KI</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Suche" aria-label="Suche" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Suche</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Nutzung</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../nutzung.html">1. Wie nutzt du dieses Buch am besten?</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../live_code.html">1.3. Programmieren direkt in diesem Buch</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parsons_problems_einfuehrung.html">1.4. Parsons-Probleme</a></li>
</ul>
</details></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Objektorienterte Programmierung (OOP)</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../oop/t01_einstieg.html">2. Einf√ºhrung in OOP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../oop/t02_kapselung.html">3. Datenkapselung</a></li>
<li class="toctree-l1"><a class="reference internal" href="../oop/t03_vererbung.html">4. Vererbung</a></li>
<li class="toctree-l1"><a class="reference internal" href="../oop/t05_interfaces.html">5. Interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../oop/t06_klassenvariablen.html">6. Klassenvariablen</a></li>
<li class="toctree-l1"><a class="reference internal" href="../oop/t07_assoziationen.html">7. Assoziationen</a></li>
<li class="toctree-l1"><a class="reference internal" href="../oop/t08_3SA.html">8. 3SA - Drei-Schichten-Architektur</a></li>
<li class="toctree-l1"><a class="reference internal" href="../oop/t09_sequenzdiagramme.html">9. Sequenzdiagramme</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Datenbanken</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../db/t10_einstieg_db.html">10. Einstieg Datenbanken</a></li>
<li class="toctree-l1"><a class="reference internal" href="../db/t11_erm.html">11. Entity-Relationship-Modell (ERM)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../db/t12_erm_rm.html">12. Vom ERM ins Relationale Modell (RM)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../db/t13_normalisierung.html">13. Normalisierung</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Datenstrukturen</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../datenstrukturen/datenstrukturen_allgemein.html">14. Abstrakte Datentypen (ADT) vs Datenstrukturen</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../datenstrukturen/listen_einfuehrung.html">15. Listen</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../datenstrukturen/verkettete_listen.html">15.2. Verkettete Listen</a></li>

<li class="toctree-l2"><a class="reference internal" href="../datenstrukturen/verkettete_liste_operationen1.html">15.4. Operationen f√ºr verkettete Listen implementieren (Teil 1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../datenstrukturen/verkettete_liste_operationen2.html">15.5. Operationen f√ºr verkettete Listen implementieren (Teil 2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../datenstrukturen/verkettete_liste_operationen_loesungen.html">15.6. L√∂sungen: Operationen f√ºr verkettete Listen implementieren</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../datenstrukturen/stapel_und_warteschlangen_intro.html">16. Stapel und Warteschlangen</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../datenstrukturen/stack.html">16.1. Stapel (Stack)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../datenstrukturen/stack-aufgaben.html">16.2. √úbungen zu Stapeln</a></li>
<li class="toctree-l2"><a class="reference internal" href="../datenstrukturen/warteschlangen.html">16.3. Warteschlangen</a></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="../datenstrukturen/assoziative_arrays.html">17. Assoziative Arrays</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../datenstrukturen/baeume.html">18. B√§ume</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../datenstrukturen/binaerbaeume.html">18.4. Bin√§rb√§ume</a></li>
<li class="toctree-l2"><a class="reference internal" href="../datenstrukturen/suchbaeume.html">18.5. Bin√§re Suchb√§ume</a></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="../datenstrukturen/klausurvorbereitung_mit_loesungen.html">19. Aufgaben zur Vorbereitung auf Klausur und Abitur</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">K√ºnstliche Intelligenz</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="ki_allgemein.html">20. K√ºnstliche Intelligenz: Einf√ºhrung</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="knearestneighbor.html">21. Der k-N√§chste-Nachbarn-Algorithmus</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="knearestneighbor2.html">21.6. Eigenschaften und Varianten des k-N√§chste-Nachbarn-Algorithmus</a></li>

</ul>
</details></li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="kmeansclustering.html">22. k-Means-Clustering</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="kmeansclustering2_aufgabe.html">22.8. Programmierung des Algorithmus</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">22.9. Programmierung des Algorithmus (L√∂sung)</a></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="entscheidungsbaumlernen.html">23. Entscheidungsb√§ume lernen</a></li>
<li class="toctree-l1"><a class="reference internal" href="minimax.html">24. Der Minimax-Algorithmus</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-launch-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Launch interactive content">
    <i class="fas fa-rocket"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li>
<button onclick="initThebeSBT()"
  class="btn btn-sm btn-launch-thebe dropdown-item"
  title="Launch Thebe"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-play"></i>
  </span>
<span class="btn__text-container">Live Code</span>
</button>
</li>
      
  </ul>
</div>



<a href="https://github.com/jil91/ds_ki-js2" target="_blank"
   class="btn btn-sm btn-source-repository-button"
   title="Quell-Repository"
   data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Laden Sie diese Seite herunter">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/ki/kmeansclustering2_loesung.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Quelldatei herunterladen"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="In PDF drucken"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Vollbildmodus"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Suche" aria-label="Suche" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Programmierung des Algorithmus (L√∂sung)</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Inhalt </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pseudocode">22.9.1. Pseudocode</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#vorentlastungen">22.9.2. Vorentlastungen</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#unit-tests">22.9.2.1. Unit Tests</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#datenpunkt-klasse">22.9.2.2. <code class="docutils literal notranslate"><span class="pre">Datenpunkt</span></code>-Klasse</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#generiere-datenpunkte">22.9.2.3. <code class="docutils literal notranslate"><span class="pre">generiere_datenpunkte()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#initialisiere-zentroiden">22.9.2.4. <code class="docutils literal notranslate"><span class="pre">initialisiere_zentroiden()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a1-berechne-euklidische-distanz">22.9.3. A1: <code class="docutils literal notranslate"><span class="pre">berechne_euklidische_distanz()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a2-finde-naechsten-zentroiden">22.9.4. A2: <code class="docutils literal notranslate"><span class="pre">finde_naechsten_zentroiden()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a3-datenpunkte-zuweisen">22.9.5. A3: <code class="docutils literal notranslate"><span class="pre">datenpunkte_zuweisen()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a4-berechne-zentroid-koordinaten">22.9.6. A4: <code class="docutils literal notranslate"><span class="pre">berechne_zentroid_koordinaten()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a5-aktualisiere-zentroiden">22.9.7. A5: <code class="docutils literal notranslate"><span class="pre">aktualisiere_zentroiden()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#finale-k-means">22.9.8. Finale: <code class="docutils literal notranslate"><span class="pre">k_means()</span></code></a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="programmierung-des-algorithmus-losung">
<h1><span class="section-number">22.9. </span>Programmierung des Algorithmus (L√∂sung)<a class="headerlink" href="#programmierung-des-algorithmus-losung" title="Link to this heading">#</a></h1>
<p>Wir werden uns nun Schritt f√ºr Schritt die n√∂tigen Methoden den k-Means-Clustering Algorithmus erarbeiten. Um am Ende nicht einen gro√üen Codeblock erstellen zu m√ºssen, werden wir soviel Vorarbeit wie m√∂glich erledigen. So kannst du dich am Ende ganz auf die Implementierung der Teile des Algorithmus konzentrieren [Stichwort: externe kognitive Belastung gering halten, siehe <a class="reference external" href="https://de.wikipedia.org/wiki/Cognitive_Load_Theory">Cognitive Load Theory (CLT)</a> üòâ]</p>
<section id="pseudocode">
<h2><span class="section-number">22.9.1. </span>Pseudocode<a class="headerlink" href="#pseudocode" title="Link to this heading">#</a></h2>
<p>Nochmals die Grundidee des <a class="reference internal" href="kmeansclustering.html#ablauf-k-means-algorithmus"><span class="std std-ref">Algorithmus</span></a>:</p>
<ol class="arabic simple">
<li><p><strong>Clusterzentren initialisieren:</strong> Zu Beginn werden <span class="math notranslate nohighlight">\(k\)</span> Zentroiden (Mittelwerte der Cluster) zuf√§llig oder nach einer bestimmten Heuristik gew√§hlt.</p></li>
<li><p><strong>Datenpunkte zuweisen:</strong> Jeder Datenpunkt wird dem n√§chstgelegenen Clusterzentrum zugeordnet. Diese Zuordnung basiert √ºblicherweise auf der euklidischen Distanz.</p></li>
<li><p><strong>Zentroiden aktualisieren:</strong> Nach der Zuordnung werden die Zentroiden neu berechnet, indem der Mittelwert aller Punkte in jedem Cluster bestimmt wird.</p></li>
<li><p><strong>Wiederholen</strong>: Die Schritte der Zuordnung und Aktualisierung werden wiederholt, bis sich die Clusterzentren nicht mehr √§ndern oder eine maximale Anzahl von Iterationen erreicht wurde.</p></li>
</ol>
<p>Folgend siehst du die Umsetzung des Algorithmus in Pseudocode nach der Formelsammlung, vervollst√§ndigt mit Kommentaren.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">OPERATION</span> <span class="n">k_means</span><span class="p">(</span>
    <span class="n">daten</span><span class="p">:</span> <span class="n">Liste</span><span class="o">&lt;</span><span class="n">Datenpunkt</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">max_iterationen</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="p">:</span> <span class="p">(</span><span class="n">Liste</span><span class="o">&lt;</span><span class="n">Datenpunkt</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Liste</span><span class="o">&lt;</span><span class="n">Datenpunkt</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="n">Lokale</span> <span class="n">Variablen</span><span class="p">:</span> 
        <span class="n">zentroiden</span><span class="p">:</span> <span class="n">Liste</span><span class="o">&lt;</span><span class="n">Datenpunkt</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">neue_zentroiden</span><span class="p">:</span> <span class="n">Liste</span><span class="o">&lt;</span><span class="n">Datenpunkt</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">cluster</span><span class="p">:</span> <span class="n">Liste</span><span class="o">&lt;</span><span class="n">Datenpunkt</span><span class="o">&gt;</span>

    <span class="c1"># Initialisierung der Zentroiden</span>
    <span class="n">zentroiden</span> <span class="o">=</span> <span class="n">initialisiere_zentroiden</span><span class="p">(</span><span class="n">daten</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

    <span class="c1"># Hauptalgorithmus: Wiederhole f√ºr maximal max_iterationen</span>
    <span class="n">F√úR</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span> <span class="n">BIS</span> <span class="n">max_iterationen</span> <span class="n">SCHRITT</span> <span class="mi">1</span>
        <span class="c1"># Cluster-Zuordnung: Weise jeden Datenpunkt dem n√§chsten Zentroiden zu</span>
        <span class="n">cluster</span> <span class="o">=</span> <span class="n">berechne_cluster</span><span class="p">(</span><span class="n">daten</span><span class="p">,</span> <span class="n">zentroiden</span><span class="p">)</span>

        <span class="c1"># Zentroiden-Aktualisierung: Berechne die neuen Zentroiden als Mittelwert der zugeordneten Punkte</span>
        <span class="n">neue_zentroiden</span> <span class="o">=</span> <span class="n">aktualisiere_zentroiden</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span>

        <span class="c1"># Abbruchbedingung: Wenn die Zentroiden sich nicht mehr √§ndern, ist der Algorithmus fertig</span>
        <span class="n">WENN</span> <span class="n">neue_zentroiden</span> <span class="o">==</span> <span class="n">zentroiden</span>  <span class="c1"># Das ist die Abbruchbedingung!</span>
            <span class="n">ABBRUCH</span>
        <span class="n">ENDE</span> <span class="n">WENN</span>

        <span class="c1"># Aktualisiere die Zentroiden f√ºr die n√§chste Iteration</span>
        <span class="n">zentroiden</span> <span class="o">=</span> <span class="n">neue_zentroiden</span>
    <span class="n">ENDE</span> <span class="n">F√úR</span>

    <span class="c1"># R√ºckgabe der finalen Cluster-Zuordnung und Zentroiden</span>
    <span class="n">R√úCKGABE</span> <span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">zentroiden</span><span class="p">)</span>
</pre></div>
</div>
<p>Laut Pseudocode ben√∂tigen wir die Methoden <code class="docutils literal notranslate"><span class="pre">initialisiere_zentroiden()</span></code> <code class="docutils literal notranslate"><span class="pre">datenpunkte_zuweisen()</span></code> und <code class="docutils literal notranslate"><span class="pre">aktualisiere_zentroiden()</span></code>. Die Methode <code class="docutils literal notranslate"><span class="pre">initialisiere_zentroiden()</span></code> ist bereits implementiert.</p>
<p>Die beiden anderen Methoden sind deine Aufgabe. In beiden F√§llen ben√∂tigst du die Eukledische Distanz (<strong>A1</strong>).<br />
Dann brauchst du eine Methode, die entscheidet, welcher Zentroid der n√§chste zu einem Datenpunkt ist (<strong>A2</strong>). Mit dieser Methode kannst du dann die Datenpunkte den Clustern zuweisen (<strong>A3</strong>).<br />
Danach m√ºssen die Koordinaten der Zentroiden neu berechnet werden. Zun√§chst f√ºr einen (<strong>A4</strong>), dann f√ºr alle Zentroiden (<strong>A5</strong>).</p>
<p><strong>Deine Aufgaben sind:</strong></p>
<ul class="simple">
<li><p><a class="reference internal" href="#loesung1"><span class="std std-ref">A1</span></a>: <code class="docutils literal notranslate"><span class="pre">berechne_euklidische_distanz()</span></code></p></li>
<li><p><a class="reference internal" href="#loesung2"><span class="std std-ref">A2</span></a>: <code class="docutils literal notranslate"><span class="pre">finde_naechsten_zentroiden()</span></code></p></li>
<li><p><a class="reference internal" href="#loesung3"><span class="std std-ref">A3</span></a>: <code class="docutils literal notranslate"><span class="pre">datenpunkte_zuweisen()</span></code></p></li>
<li><p><a class="reference internal" href="#loesung4"><span class="std std-ref">A4</span></a>: <code class="docutils literal notranslate"><span class="pre">berechne_zentroid_koordinaten()</span></code></p></li>
<li><p><a class="reference internal" href="#loesung5"><span class="std std-ref">A5</span></a>: <code class="docutils literal notranslate"><span class="pre">aktualisiere_zentroiden()</span></code></p></li>
</ul>
<p>Wenn alle Aufgaben erledigt, sollte <a class="reference internal" href="#k-means-final"><span class="std std-ref">die Methode <code class="docutils literal notranslate"><span class="pre">k_means()</span></code></span></a> korrekt funktionieren üòé.</p>
<div class="note admonition">
<p class="admonition-title">Hinweis</p>
<p>Die folgenden Unterpunkte bis zur <a class="reference internal" href="#loesung1"><span class="std std-ref">ersten Aufgabe</span></a> sind nicht essentiel, um den Algorithmus zu verstehen, aber dennoch hilfreich f√ºr die sp√§tere Implementierung. Und auch generell wichtig f√ºr das vielleicht sp√§tere Leben als ProgrammiererIn.</p>
</div>
</section>
<section id="vorentlastungen">
<h2><span class="section-number">22.9.2. </span>Vorentlastungen<a class="headerlink" href="#vorentlastungen" title="Link to this heading">#</a></h2>
<p>Wir werden nun vor der ersten Aufgabe folgende Schritte bereits erledigen:</p>
<ul class="simple">
<li><p>Konfiguration von Unit Tests: f√ºr das Beschreiben der Methoden und f√ºr nachvollziehbare Testf√§lle</p></li>
<li><p>Klasse <code class="docutils literal notranslate"><span class="pre">Datenpunkt</span></code>: f√ºr das Handling von X- und Y-Koordinaten</p></li>
<li><p>Methode <code class="docutils literal notranslate"><span class="pre">generiere_datenpunkte()</span></code>: f√ºr das Generieren von zuf√§lligen Datenpunkten</p></li>
<li><p>Methode <code class="docutils literal notranslate"><span class="pre">initialisiere_zentroiden()</span></code>: f√ºr das Initialisieren der ersten Zentroiden</p></li>
</ul>
<p>In den Aufgaben selber sind auch teilweise schon Tipps und Hilfen. Achte auf die Stelle <code class="docutils literal notranslate"><span class="pre">...</span>&#160; <span class="pre">#</span> <span class="pre">Hier</span> <span class="pre">die</span> <span class="pre">weitere</span> <span class="pre">L√∂sung</span> <span class="pre">erg√§nzen</span></code>: nur dort muss dein Code hin üòâ.</p>
<section id="unit-tests">
<h3><span class="section-number">22.9.2.1. </span>Unit Tests<a class="headerlink" href="#unit-tests" title="Link to this heading">#</a></h3>
<p>Wir werden zum Testen unserer Methoden <a class="reference external" href="https://en.wikipedia.org/wiki/Unit_testing">Unit-Tests</a> verwenden. Das sind kleine, automatisierte Tests, die jeweils eine <strong>einzelne</strong> Funktion oder Methode in einem Programm √ºberpr√ºfen. Sie helfen sicherzustellen, dass jede Komponente des Codes genau das tut, was sie tun soll. Stell dir Unit-Tests wie eine Checkliste vor, die jede Funktion Schritt f√ºr Schritt √ºberpr√ºft, ob sie die erwarteten Ergebnisse liefert.</p>
<p>Bei den einzelnen Methoden sind bereits jeweils Unit-Tests hinterlegt, sodass sie dir eine Hilfe bei der Implementierung geben. Wenn du die Test-Methoden studierst, siehst du, wie die zu implementierenden Methoden aufgerufen werden.</p>
<div class="note dropdown admonition">
<p class="admonition-title">Bei Interesse: weitere Infos zu Unit-Tests</p>
<p><strong>Vorteile von Unit-Tests:</strong></p>
<ul class="simple">
<li><p><strong>Fr√ºhes Erkennen von Fehlern</strong>: Unit-Tests helfen dabei, Fehler fr√ºh zu finden, noch bevor der ganze Code zusammengesetzt wird. Das macht es einfacher und billiger, diese Fehler zu beheben.</p></li>
<li><p><strong>Sicherheit bei √Ñnderungen</strong>: Wenn du etwas an deinem Code √§nderst, kannst du die Unit-Tests erneut ausf√ºhren, um sicherzustellen, dass die √Ñnderung nichts kaputt gemacht hat. Sie geben also Vertrauen, dass alte Funktionen nach wie vor korrekt laufen.</p></li>
<li><p><strong>Besserer Code</strong>: Oft sorgt das Schreiben von Unit-Tests daf√ºr, dass der eigentliche Code sauberer und verst√§ndlicher wird, weil man genau √ºberlegen muss, was die Funktion tut.</p></li>
<li><p><strong>Dokumentation</strong>: Unit-Tests dokumentieren, wie der Code verwendet wird und welche Eingaben erwartete Ausgaben ergeben. Das hilft anderen Entwickler:innen (oder deinem zuk√ºnftigen Selbst), den Code besser zu verstehen.</p></li>
</ul>
<p>Mit Unit-Tests bist du also gut aufgestellt, um zuverl√§ssigen und stabilen Code zu schreiben, der leichter zu warten ist.</p>
</div>
<p>Folgend ist wird definiert, wie die Erfolgs- und Fehlerausgabe in einem f√ºr uns gut lesbaren Format ausgegeben wird. Du musst es nicht verstehen, es ist nur wichtig, bei den Implementierungen <code class="docutils literal notranslate"><span class="pre">run_doctests_mit_lesbarer_ausgabe(methoden_name)</span></code> auszuf√ºhren, um die Methode zu testen und die Ausgabe dazu erhalten. Du erh√§ltst immer die Info, ob die Methode erfolgreich implementiert wurde oder ob es noch Tests gibt, die fehlschlagen.</p>
<div class="cell tag_hide-cell docutils container">
<details class="admonition hide above-input">
<summary aria-label="Toggle hidden content">
<p class="collapsed admonition-title">Show code cell content</p>
<p class="expanded admonition-title">Hide code cell content</p>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># F√ºr die Unit Tests ben√∂tigen wir das Modul doctest. Damit k√∂nnen wir die Docstrings in den Funktionen testen.</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">doctest</span>

<span class="c1"># Damit die Ausgabe f√ºr dich gut lesbar ist, verwenden wir eine eigenes Output-Format</span>
<span class="k">class</span><span class="w"> </span><span class="nc">CustomOutputChecker</span><span class="p">(</span><span class="n">doctest</span><span class="o">.</span><span class="n">OutputChecker</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Diese Klasse ist ein Wrapper f√ºr den Doctest-OutputChecker, um die Ausgabe zu formatieren.&quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">output_difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">example</span><span class="p">,</span> <span class="n">got</span><span class="p">,</span> <span class="n">optionflags</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Diese Funktion gibt die Testergebnisse in einer lesbaren Form zur√ºck.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">Test fehlgeschlagen:</span>
<span class="s2">  Beispiel: </span><span class="si">{</span><span class="n">example</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="si">}</span>
<span class="s2">  Erwartet: </span><span class="si">{</span><span class="n">example</span><span class="o">.</span><span class="n">want</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="si">}</span>
<span class="s2">  Erhalten: </span><span class="si">{</span><span class="n">got</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="si">}</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">run_doctests_mit_lesbarer_ausgabe</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Diese Funktion f√ºhrt die Doctests aus und gibt eine lesbare Ausgabe zur√ºck.</span>
<span class="sd">    Args:</span>
<span class="sd">        func (function): Die Funktion, die getestet werden soll.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">runner</span> <span class="o">=</span> <span class="n">doctest</span><span class="o">.</span><span class="n">DocTestRunner</span><span class="p">(</span><span class="n">checker</span><span class="o">=</span><span class="n">CustomOutputChecker</span><span class="p">(),</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    <span class="n">tests</span> <span class="o">=</span> <span class="n">doctest</span><span class="o">.</span><span class="n">DocTestFinder</span><span class="p">()</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="n">total_failed</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">test</span> <span class="ow">in</span> <span class="n">tests</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">runner</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
        <span class="n">total_failed</span> <span class="o">+=</span> <span class="n">result</span><span class="o">.</span><span class="n">failed</span>
    
    <span class="n">runner</span><span class="o">.</span><span class="n">summarize</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">total_failed</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">() wurde erfolgreich implementiert!&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">() hat </span><span class="si">{</span><span class="n">total_failed</span><span class="si">}</span><span class="s1"> fehlgeschlagene Tests&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</details>
</div>
<p>In Python k√∂nnen wir Funktionen und Klassen mit Docstrings dokumentieren. Docstrings sind mehrzeilige Kommentare unter der <code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">...</span></code>-Zeile, die erkl√§ren, was die Funktion macht, welche Parameter sie ben√∂tigt und was sie zur√ºckgibt. Au√üerdem k√∂nnen wir Beispiel-Aufrufe direkt in die Docstrings schreiben, um die Funktionsweise zu zeigen. Und damit haben wir auch schon unsere Unit Tests, wie praktisch! Denn iese Beispiele kann man mit den Unit Tests einfach nachspielen. Im Beispiel unten erfolgt das mit der Zeile</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">run_doctests_mit_lesbarer_ausgabe</span><span class="p">(</span><span class="n">ist_gerade</span><span class="p">)</span>
</pre></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">ist_gerade</span><span class="p">(</span><span class="n">zahl</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pr√ºft, ob eine Zahl gerade ist.</span>
<span class="sd">    Args:</span>
<span class="sd">        zahl (int): Die zu pr√ºfende Zahl</span>
<span class="sd">    Returns:</span>
<span class="sd">        bool: True, wenn die Zahl gerade ist, sonst False</span>
<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; ist_gerade(2)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ist_gerade(3)</span>
<span class="sd">        False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Zum Testen kannst du die Funktion mal so ab√§ndern, dass sie ein falsches Ergebnis zur√ºckgibt</span>
    <span class="c1"># return True # auskommentieren, um den Test fehlschlagen zu lassen</span>
    <span class="k">return</span> <span class="n">zahl</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>

<span class="c1"># Unit Test ausf√ºhren</span>
<span class="n">run_doctests_mit_lesbarer_ausgabe</span><span class="p">(</span><span class="n">ist_gerade</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="datenpunkt-klasse">
<h3><span class="section-number">22.9.2.2. </span><code class="docutils literal notranslate"><span class="pre">Datenpunkt</span></code>-Klasse<a class="headerlink" href="#datenpunkt-klasse" title="Link to this heading">#</a></h3>
<p>Damit du die Koordinaten der Datenpunkte und der Zentroiden bequem veralten k√∂nnen, ist die Hilfsklasse <code class="docutils literal notranslate"><span class="pre">Datenpunkt</span></code> bereits vorhanden. In dieser Klasse erweitern wir noch die internen Methoden <code class="docutils literal notranslate"><span class="pre">__eq__()</span></code> und <code class="docutils literal notranslate"><span class="pre">__hash__()</span></code>, damit wir es sp√§ter leichter haben, die neuen Zentroiden mit den alten Zentroiden der vorigen Iteration zu vergleichen (siehe Schritt 4 des <a class="reference internal" href="kmeansclustering.html#ablauf-k-means-algorithmus"><span class="std std-ref">Algorithmus</span></a>). Es w√§re auch m√∂glich, die Koordinaten in verschachtelten Arrays zu verwalten, aber die L√∂sung einer eigenen Klasse ist eleganter und wir k√∂nnen Komplexit√§t in diese Klasse auslagern. F√ºr dich wichtig zu wissen: einen neuen Datenpunkt kannst du mit <code class="docutils literal notranslate"><span class="pre">punkt</span> <span class="pre">=</span> <span class="pre">Datenpunkt(1.2345,</span> <span class="pre">6.789)</span></code> erzeugen.</p>
<div class="note admonition">
<p class="admonition-title">Zentroiden &amp; Datenpunkte</p>
<p>Zentroiden sind nichts anderes als Datenpunkte wie aus den Eingabedaten. Beide zeichnet aus, dass sie <code class="docutils literal notranslate"><span class="pre">X</span></code>- und <code class="docutils literal notranslate"><span class="pre">Y</span></code>-Koordinaten haben.</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Datenpunkt</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Klasse, die einen Datenpunkt repr√§sentiert mit XY-Koordinaten.&quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Erzeugt einen Datenpunkt mit den gegebenen Koordinaten, gerundet auf zwei Dezimalstellen.</span>
<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; punkt = Datenpunkt(1.2345, 6.789)</span>
<span class="sd">            &gt;&gt;&gt; punkt.x</span>
<span class="sd">            1.23</span>
<span class="sd">            &gt;&gt;&gt; punkt.y</span>
<span class="sd">            6.79</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">anderer_datenpunkt</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Vergleicht zwei Datenpunkte basierend auf ihren Koordinaten.</span>
<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; Datenpunkt(1.23, 4.56) == Datenpunkt(1.23, 4.56)</span>
<span class="sd">            True</span>
<span class="sd">            &gt;&gt;&gt; Datenpunkt(1.23, 4.56) == Datenpunkt(0.00, 4.56)</span>
<span class="sd">            False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">anderer_datenpunkt</span><span class="p">,</span> <span class="n">Datenpunkt</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">anderer_datenpunkt</span><span class="o">.</span><span class="n">x</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="n">anderer_datenpunkt</span><span class="o">.</span><span class="n">y</span>
        <span class="k">return</span> <span class="kc">False</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Berechnet den Hashwert eines Datenpunktes.</span>
<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; hash(Datenpunkt(1.23, 4.56)) == hash(Datenpunkt(1.23, 4.56))</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gibt eine lesbare Repr√§sentation eines Datenpunktes zur√ºck.</span>
<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; repr(Datenpunkt(1.23, 4.56))</span>
<span class="sd">            &#39;Datenpunkt(1.23, 4.56)&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Datenpunkt(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="si">}</span><span class="s2">)&quot;</span>

<span class="n">run_doctests_mit_lesbarer_ausgabe</span><span class="p">(</span><span class="n">Datenpunkt</span><span class="o">.</span><span class="fm">__init__</span><span class="p">)</span>
<span class="n">run_doctests_mit_lesbarer_ausgabe</span><span class="p">(</span><span class="n">Datenpunkt</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">)</span>
<span class="n">run_doctests_mit_lesbarer_ausgabe</span><span class="p">(</span><span class="n">Datenpunkt</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">)</span>
<span class="n">run_doctests_mit_lesbarer_ausgabe</span><span class="p">(</span><span class="n">Datenpunkt</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="generiere-datenpunkte">
<h3><span class="section-number">22.9.2.3. </span><code class="docutils literal notranslate"><span class="pre">generiere_datenpunkte()</span></code><a class="headerlink" href="#generiere-datenpunkte" title="Link to this heading">#</a></h3>
<p>Wir ben√∂tigen automatische Eingabedaten und wir m√∂chten unsere <code class="docutils literal notranslate"><span class="pre">kmeans()</span></code>-Methode mit beliebig gro√üen Datens√§tzen testen k√∂nnen. Daf√ºr werden wir Methode <code class="docutils literal notranslate"><span class="pre">generiere_datenpunkte()</span></code> verwenden. Dieser k√∂nnen wir die Anzahl der gew√ºnschten Datenpunkte und den gew√ºnschten Zahlenraum angeben. Wir erhalten eine Liste von <code class="docutils literal notranslate"><span class="pre">Datenpunkten</span></code> zur√ºck.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">random</span>

<span class="k">def</span><span class="w"> </span><span class="nf">generiere_datenpunkte</span><span class="p">(</span><span class="n">anzahl_datenpunkte</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">zahlenraum</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">randomseed</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Datenpunkt</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generiert eine Liste von zuf√§lligen Datenpunkten im angegebenen Zahlenraum.</span>
<span class="sd">    Args:</span>
<span class="sd">        anzahl_datenpunkte (int): Anzahl der zu generierenden Datenpunkte</span>
<span class="sd">        zahlenraum (int): Gr√∂√üe des Zahlenraums, in dem die Datenpunkte generiert werden</span>
<span class="sd">    Returns:</span>
<span class="sd">        list[Datenpunkt]: Liste von zuf√§lligen Datenpunkten</span>
<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; datenpunkte = generiere_datenpunkte(3, 10)</span>
<span class="sd">        &gt;&gt;&gt; len(datenpunkte)</span>
<span class="sd">        3</span>
<span class="sd">        &gt;&gt;&gt; all(0 &lt;= datenpunkt.x &lt;= 10 and 0 &lt;= datenpunkt.y &lt;= 10 for datenpunkt in datenpunkte)</span>
<span class="sd">        True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Damit wir einerseits zuf√§llige Zahlen generieren k√∂nnen, aber andererseits auch reproduzierbare</span>
    <span class="c1"># Ergebnisse erhalten, setze wir den Zufallsgenerator auf einen fixen Wert.</span>
    <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">randomseed</span><span class="p">)</span>
    <span class="c1"># Set, um Duplikate zu vermeiden</span>
    <span class="n">datenpunkte</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="c1"># Solange die Anzahl der generierten Datenpunkte kleiner als die gew√ºnschte Anzahl ist,</span>
    <span class="c1"># neue Datenpunkte generieren und hinzuf√ºgen</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">datenpunkte</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">anzahl_datenpunkte</span><span class="p">:</span>
        <span class="c1"># Zuf√§llige Koordinaten im Zahlenraum generieren</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">zahlenraum</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">zahlenraum</span><span class="p">)</span>
        <span class="n">datenpunkt</span> <span class="o">=</span> <span class="n">Datenpunkt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">datenpunkte</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">datenpunkt</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">datenpunkte</span><span class="p">)</span>

<span class="n">run_doctests_mit_lesbarer_ausgabe</span><span class="p">(</span><span class="n">generiere_datenpunkte</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="initialisiere-zentroiden">
<h3><span class="section-number">22.9.2.4. </span><code class="docutils literal notranslate"><span class="pre">initialisiere_zentroiden()</span></code><a class="headerlink" href="#initialisiere-zentroiden" title="Link to this heading">#</a></h3>
<p>Im ersten Schritt des k-means Algorithmus werden die Startzentroiden bestimmt. Die Methode <code class="docutils literal notranslate"><span class="pre">initialisiere_zentroiden()</span></code> w√§hlt aus der √ºbergebenen Liste von <code class="docutils literal notranslate"><span class="pre">Datenpunkten</span></code> die gew√ºnschte Anzahl der Zentroiden zuf√§llig aus. Die Auswahl ist zwar <strong>zuf√§llig</strong>, bleibt <strong>aber reproduzierbar</strong>, weil wir in der Methode <code class="docutils literal notranslate"><span class="pre">generiere_datenpunkte</span></code> den Zufallsgenerator auf einen fixen Wert gesetzt haben. Die Methode gibt eine Liste von <code class="docutils literal notranslate"><span class="pre">Datenpunkten</span></code> zur√ºck.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">initialisiere_zentroiden</span><span class="p">(</span><span class="n">datenpunkte</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Datenpunkt</span><span class="p">],</span> <span class="n">anzahl_zentroiden</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Datenpunkt</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    W√§hlt zuf√§llig die angegebene Anzahl von Zentroiden aus den Datenpunkten aus.</span>
<span class="sd">    Args:</span>
<span class="sd">        datenpunkte: Liste von Datenpunkten, aus denen die Zentroiden ausgew√§hlt werden.</span>
<span class="sd">        anzahl_zentroiden: Anzahl der Zentroiden, die initialisiert werden sollen.</span>
<span class="sd">    Returns:</span>
<span class="sd">        list[Datenpunkt]: Liste der initialisierten Zentroiden.</span>
<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; datenpunkte = [Datenpunkt(1.4, 4.5), Datenpunkt(5.2, 8.3), Datenpunkt(3.1, 9.2), Datenpunkt(3.1, 6.2)]</span>
<span class="sd">        &gt;&gt;&gt; anzahl_zentroiden = 2</span>
<span class="sd">        &gt;&gt;&gt; result = initialisiere_zentroiden(datenpunkte, anzahl_zentroiden)</span>
<span class="sd">        &gt;&gt;&gt; len(result)</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; all(zentroid in datenpunkte for zentroid in result)</span>
<span class="sd">        True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">zentroiden</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">datenpunkte</span><span class="p">,</span> <span class="n">anzahl_zentroiden</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">zentroiden</span>

<span class="n">run_doctests_mit_lesbarer_ausgabe</span><span class="p">(</span><span class="n">initialisiere_zentroiden</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<hr class="docutils" />
<div class="tip admonition">
<p class="admonition-title">Your turn</p>
<p><strong>Ab hier beginnt dein Teil der Arbeit, viel Spa√ü und Erfolg üí™</strong></p>
</div>
</section>
</section>
<section id="a1-berechne-euklidische-distanz">
<span id="loesung1"></span><h2><span class="section-number">22.9.3. </span>A1: <code class="docutils literal notranslate"><span class="pre">berechne_euklidische_distanz()</span></code><a class="headerlink" href="#a1-berechne-euklidische-distanz" title="Link to this heading">#</a></h2>
<p>Zum Warmwerden: du brauchst eine Methode, welche dir die Distanz zwischen zwei Datenpunkten berechnet. Wir werden hierf√ºr als <a class="reference internal" href="ki_allgemein.html#term-Distanzmasze"><span class="xref std std-term">Distanzma√üe</span></a> die <a class="reference internal" href="ki_allgemein.html#term-Euklidische-Distanz"><span class="xref std std-term">Euklidische Distanz</span></a> verwenden. Die Methode erh√§lt zwei Datenpunkte und gibt die Distanz auf zwei Nachkommastellen gerundet zur√ºck. Zum runden ben√∂tigst du die Methode <a class="reference external" href="https://www.w3schools.com/python/ref_func_round.asp">round()</a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">berechne_euklidische_distanz</span><span class="p">(</span><span class="n">datenpunkt1</span><span class="p">:</span> <span class="n">Datenpunkt</span><span class="p">,</span> <span class="n">datenpunkt2</span><span class="p">:</span> <span class="n">Datenpunkt</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Berechnet die euklidische Distanz zu einem anderen Datenpunkt auf zwei Dezimalstellen gerundet.</span>
<span class="sd">    Args:</span>
<span class="sd">        datenpunkt1: Erster Datenpunkt.</span>
<span class="sd">        datenpunkt2: Zweiter Datenpunkt.</span>
<span class="sd">    Returns:</span>
<span class="sd">        float: Euklidische Distanz zwischen den beiden Datenpunkten auf zwei Dezimalstellen gerundet.</span>
<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; datenpunkt1 = Datenpunkt(1.0, 2.0)</span>
<span class="sd">        &gt;&gt;&gt; datenpunkt2 = Datenpunkt(3.0, 4.0)</span>
<span class="sd">        &gt;&gt;&gt; berechne_euklidische_distanz(datenpunkt1, datenpunkt2)</span>
<span class="sd">        2.83</span>
<span class="sd">        &gt;&gt;&gt; berechne_euklidische_distanz(datenpunkt1, datenpunkt1)</span>
<span class="sd">        0.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Du ben√∂tigst den Satz des Pythagoras: c = Wurzel von (a^2 + b^2)</span>
    <span class="c1"># Beispiele f√ºr Potenzen, Wurzeln und Runden:</span>
    <span class="n">potenz_von_3</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">wurzel_aus_9</span> <span class="o">=</span> <span class="mi">9</span> <span class="o">**</span> <span class="mf">0.5</span>
    <span class="n">pi_mit_5_nachkommastellen</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="mf">3.14159</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="o">...</span>  <span class="c1"># Hier L√∂sung erg√§nzen</span>
    <span class="n">diff_x</span> <span class="o">=</span> <span class="n">datenpunkt1</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">datenpunkt2</span><span class="o">.</span><span class="n">x</span>
    <span class="n">diff_y</span> <span class="o">=</span> <span class="n">datenpunkt1</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">datenpunkt2</span><span class="o">.</span><span class="n">y</span>
    <span class="n">distanz</span> <span class="o">=</span> <span class="p">(</span><span class="n">diff_x</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">diff_y</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>
    <span class="k">return</span> <span class="nb">round</span><span class="p">(</span><span class="n">distanz</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="n">run_doctests_mit_lesbarer_ausgabe</span><span class="p">(</span><span class="n">berechne_euklidische_distanz</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="a2-finde-naechsten-zentroiden">
<span id="loesung2"></span><h2><span class="section-number">22.9.4. </span>A2: <code class="docutils literal notranslate"><span class="pre">finde_naechsten_zentroiden()</span></code><a class="headerlink" href="#a2-finde-naechsten-zentroiden" title="Link to this heading">#</a></h2>
<p>Nun wollen wir f√ºr einen <code class="docutils literal notranslate"><span class="pre">Datenpunkt</span></code> den n√§chstgelegenen Zentroiden ermitteln. Wir bekommen daf√ºr die Liste von Zentroiden √ºbergeben und m√ºssen hieraus nun den Zentroiden ermitteln, zu dem die Distanz des <code class="docutils literal notranslate"><span class="pre">Datenpunkts</span></code> am geringsten ist. √úberlege dir vorher, wie du vorgehen m√∂chtest. Zur√ºckgegeben wird der Index des ermittelten Zentroiden. Wenn also der 3. Zentroid der n√§chstgelegene ist, dann muss der Index 2 zur√ºckgegeben wird (da Index bei 0 beginnt).</p>
<div class="admonition-wichtiger-tipp admonition">
<p class="admonition-title">Wichtiger Tipp</p>
<p>Du ben√∂tigst die Methode <code class="docutils literal notranslate"><span class="pre">berechne_euklidische_distanz()</span></code> aus der vorigen Aufgabe!</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">finde_naechsten_zentroiden</span><span class="p">(</span><span class="n">zentroiden</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Datenpunkt</span><span class="p">],</span> <span class="n">datenpunkt</span><span class="p">:</span> <span class="n">Datenpunkt</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finde den n√§chsten Zentroiden f√ºr einen gegebenen Datenpunkt. Wenn es mehrere Zentroiden mit</span>
<span class="sd">    der gleichen minimalen Distanz gibt, wird der erste gefundene Zentroid zur√ºckgegeben. Die Zahl,</span>
<span class="sd">    die zur√ºckgegeben wird, ist der Index des Zentroiden in der Liste der Zentroiden.</span>
<span class="sd">    Args:</span>
<span class="sd">        zentroiden (list[Datenpunkt]): Liste der Zentroiden, zwischen denen der n√§chste gesucht wird.</span>
<span class="sd">        datenpunkt (Datenpunkt): Der Datenpunkt, f√ºr den der n√§chste Zentroid gesucht wird.</span>
<span class="sd">    Returns:</span>
<span class="sd">        int: Index des n√§chsten Zentroiden. </span>
<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; zentroiden = [Datenpunkt(1, 2), Datenpunkt(4, 6), Datenpunkt(3, 5)]</span>
<span class="sd">        &gt;&gt;&gt; datenpunkt = Datenpunkt(1, 1)</span>
<span class="sd">        &gt;&gt;&gt; finde_naechsten_zentroiden(zentroiden, datenpunkt)</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; datenpunkt = Datenpunkt(4, 6)</span>
<span class="sd">        &gt;&gt;&gt; finde_naechsten_zentroiden(zentroiden, datenpunkt)</span>
<span class="sd">        1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="o">...</span>  <span class="c1"># Hier L√∂sung erg√§nzen</span>
    <span class="n">geringste_distanz</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span> <span class="c1"># Erstmal die maximale Distanz w√§hlen</span>
    <span class="n">index_naechster_zentroid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">zentroid</span> <span class="ow">in</span> <span class="n">zentroiden</span><span class="p">:</span>
        <span class="n">distanz</span> <span class="o">=</span> <span class="n">berechne_euklidische_distanz</span><span class="p">(</span><span class="n">datenpunkt</span><span class="p">,</span> <span class="n">zentroid</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">distanz</span> <span class="o">&lt;</span> <span class="n">geringste_distanz</span><span class="p">:</span>
            <span class="n">geringste_distanz</span> <span class="o">=</span> <span class="n">distanz</span>
            <span class="n">index_naechster_zentroid</span> <span class="o">=</span> <span class="n">index</span>
        <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">index_naechster_zentroid</span>

<span class="n">run_doctests_mit_lesbarer_ausgabe</span><span class="p">(</span><span class="n">finde_naechsten_zentroiden</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="a3-datenpunkte-zuweisen">
<span id="loesung3"></span><h2><span class="section-number">22.9.5. </span>A3: <code class="docutils literal notranslate"><span class="pre">datenpunkte_zuweisen()</span></code><a class="headerlink" href="#a3-datenpunkte-zuweisen" title="Link to this heading">#</a></h2>
<p>Nachdem wir den n√§chsten Zentroiden zu einem Datenpunkt berechnen k√∂nnen, sind wir nun in der Lage, alle Datenpunkte zu clustern. Mit der Methode <code class="docutils literal notranslate"><span class="pre">datenpunkte_zuweisen()</span></code> k√∂nnen wir nun f√ºr jeden Datenpunkt den n√§chsten Zentroiden ermitteln und daraus die Cluster bilden.</p>
<p>In der Methode unten ist bereits das Erzeugen der leeren Cluster erfolgt, darum musst du dich nicht k√ºmmern. Was du noch erg√§nzen musst, ist das Ermitteln des n√§chsten Zentroiden zu jedem Datenpunkt. Mit dem erhaltenen Index kannst du dann in der Liste von Clustern jeden den Datenpunkt dem zugeh√∂rigen Cluster anh√§ngen.</p>
<div class="admonition-wichtiger-tipp admonition">
<p class="admonition-title">Wichtiger Tipp</p>
<p>Die Cluster sind in einer Liste enthalten. Die Cluster selber sind auch Listen. Hier unten siehst du ein Beispiel von einer Liste mit 3 Clustern.</p>
<p><code class="docutils literal notranslate"><span class="pre">clusters</span> <span class="pre">=</span> <span class="pre">[[Datenpunkt(1.0,</span> <span class="pre">1.0),</span> <span class="pre">Datenpunkt(3.0,</span> <span class="pre">3.0)],</span> <span class="pre">[Datenpunkt(5.0,</span> <span class="pre">5.0)],</span> <span class="pre">[Datenpunkt(7.0,</span> <span class="pre">7.0)]]</span></code></p>
<ul class="simple">
<li><p>Cluster an Index 0 hat die Elemente <code class="docutils literal notranslate"><span class="pre">Datenpunkt(1.0,</span> <span class="pre">1.0)</span></code> und <code class="docutils literal notranslate"><span class="pre">Datenpunkt(3.0,</span> <span class="pre">3.0)</span></code></p></li>
<li><p>Cluster an Index 1 hat das Element <code class="docutils literal notranslate"><span class="pre">Datenpunkt(5.0,</span> <span class="pre">5.0)</span></code></p></li>
<li><p>Cluster an Index 2 hat das Element <code class="docutils literal notranslate"><span class="pre">Datenpunkt(7.0,</span> <span class="pre">7.0)</span></code></p></li>
</ul>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">datenpunkte_zuweisen</span><span class="p">(</span><span class="n">datenpunkte</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Datenpunkt</span><span class="p">],</span> <span class="n">zentroiden</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Datenpunkt</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Datenpunkt</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Weist jeden Datenpunkt den entsprechenden Cluster zu.</span>
<span class="sd">    Args:</span>
<span class="sd">        datenpunkte: Liste der Datenpunkte, die den Clustern zugeordnet werden sollen.</span>
<span class="sd">        zentroiden: Liste der Zentroiden, die die Cluster repr√§sentieren.</span>
<span class="sd">    Returns:</span>
<span class="sd">        list[list[Datenpunkt]]: Liste von Clustern, wobei jeder Cluster als eine Liste von Datenpunkten dargestellt wird.</span>
<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; datenpunkte = [Datenpunkt(1.0, 1.0), Datenpunkt(3.0, 3.0), Datenpunkt(5.0, 5.0), Datenpunkt(7.0, 7.0)]</span>
<span class="sd">        &gt;&gt;&gt; zentroiden = [Datenpunkt(2.0, 2.0), Datenpunkt(4.0, 4.0), Datenpunkt(6.0, 6.0)]</span>
<span class="sd">        &gt;&gt;&gt; datenpunkte_zuweisen(datenpunkte, zentroiden)</span>
<span class="sd">        [[Datenpunkt(1.0, 1.0), Datenpunkt(3.0, 3.0)], [Datenpunkt(5.0, 5.0)], [Datenpunkt(7.0, 7.0)]]</span>

<span class="sd">        &gt;&gt;&gt; datenpunkte = [Datenpunkt(1.4, 1.2), Datenpunkt(1.6, 4.7), Datenpunkt(5.2, 8.3), Datenpunkt(5.1, 8.2), Datenpunkt(3.1, 9.2)]</span>
<span class="sd">        &gt;&gt;&gt; zentroiden = [Datenpunkt(1.0, 3.0), Datenpunkt(4.0, 5.0)]</span>
<span class="sd">        &gt;&gt;&gt; datenpunkte_zuweisen(datenpunkte, zentroiden)</span>
<span class="sd">        [[Datenpunkt(1.4, 1.2), Datenpunkt(1.6, 4.7)], [Datenpunkt(5.2, 8.3), Datenpunkt(5.1, 8.2), Datenpunkt(3.1, 9.2)]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Es wurde schon ein leere Liste f√ºr die Cluster angelegt f√ºr dich ;)</span>
    <span class="n">clusters</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Datenpunkt</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">anzahl_cluster</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">zentroiden</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">anzahl_cluster</span><span class="p">):</span>
        <span class="n">clusters</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

    <span class="c1"># Du kannst nun jeden Datenpunkt dem richtigen Cluster zuweisen, indem du den Index des</span>
    <span class="c1"># n√§chsten Zentroiden findest und den Datenpunkt dem entsprechenden Cluster hinzuf√ºgst.</span>
    <span class="c1"># Tipp 1: Du ben√∂tigst die Methode finde_naechsten_zentroiden() aus der vorigen Aufgabe</span>
    <span class="c1"># Tipp 2: um einer Liste ein weiteres Item hinzuzu√ºgen, kannst du die Methode list.append() verwenden.</span>
    <span class="o">...</span>  <span class="c1"># Hier die weitere L√∂sung erg√§nzen</span>
    <span class="k">for</span> <span class="n">datenpunkt</span> <span class="ow">in</span> <span class="n">datenpunkte</span><span class="p">:</span>
        <span class="n">index_naechster_zentroid</span> <span class="o">=</span> <span class="n">finde_naechsten_zentroiden</span><span class="p">(</span><span class="n">zentroiden</span><span class="p">,</span> <span class="n">datenpunkt</span><span class="p">)</span>
        <span class="n">clusters</span><span class="p">[</span><span class="n">index_naechster_zentroid</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">datenpunkt</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">clusters</span>

<span class="n">run_doctests_mit_lesbarer_ausgabe</span><span class="p">(</span><span class="n">datenpunkte_zuweisen</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="a4-berechne-zentroid-koordinaten">
<span id="loesung4"></span><h2><span class="section-number">22.9.6. </span>A4: <code class="docutils literal notranslate"><span class="pre">berechne_zentroid_koordinaten()</span></code><a class="headerlink" href="#a4-berechne-zentroid-koordinaten" title="Link to this heading">#</a></h2>
<p>Wir ben√∂tigen nun zum einen noch eine Funktion <code class="docutils literal notranslate"><span class="pre">berechne_zentroid_koordinaten()</span></code>, welche uns aus den Datenpunkten eines Clusters die neuen Koordinaten des Zentroiden berechnet. Diese Funktion wird dann von <code class="docutils literal notranslate"><span class="pre">aktualisiere_zentroiden()</span></code> in der n√§chsten Aufgabe verwendet, um die Zentroiden in jeder Iteration alle neu zu berechnen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">berechne_zentroid_koordinaten</span><span class="p">(</span><span class="n">datenpunkte</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Datenpunkt</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Datenpunkt</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Berechnet die Koordinaten des Zentroiden basierend auf den zugeh√∂rigen Datenpunkten.</span>
<span class="sd">    Dabei wird der Mittelwert der X- und Y-Koordinaten der Datenpunkte berechnet.</span>
<span class="sd">    Args:</span>
<span class="sd">        datenpunkte: Liste der Datenpunkte, f√ºr die der Zentroid berechnet werden soll.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Datenpunkt: Zentroid mit den berechneten Koordinaten.</span>
<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; datenpunkte = [Datenpunkt(1.0, 1.0), Datenpunkt(3.0, 3.0), Datenpunkt(5.0, 5.0)]</span>
<span class="sd">        &gt;&gt;&gt; berechne_zentroid_koordinaten(datenpunkte)</span>
<span class="sd">        Datenpunkt(3.0, 3.0)</span>
<span class="sd">        &gt;&gt;&gt; datenpunkte = [Datenpunkt(1.4, 4.5), Datenpunkt(1.6, 4.7), Datenpunkt(5.2, 8.3)]</span>
<span class="sd">        &gt;&gt;&gt; berechne_zentroid_koordinaten(datenpunkte)</span>
<span class="sd">        Datenpunkt(2.73, 5.83)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Der Zentroid wird mit den Mittelwerten der X- und Y-Koordinaten der Datenpunkte berechnet.</span>
    <span class="c1"># Du ben√∂tigst also die Summe der X- und Y-Koordinaten und die Anzahl der Datenpunkte.</span>
    <span class="c1"># Als R√ºchgabe erzeugst du einen neuen Datenpunkt mit den berechneten Koordinaten.</span>
    <span class="o">...</span>  <span class="c1"># Hier L√∂sung erg√§nzen</span>
    <span class="n">x_summe</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">y_summe</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">datenpunkt</span> <span class="ow">in</span> <span class="n">datenpunkte</span><span class="p">:</span>
        <span class="n">x_summe</span> <span class="o">+=</span> <span class="n">datenpunkt</span><span class="o">.</span><span class="n">x</span>
        <span class="n">y_summe</span> <span class="o">+=</span> <span class="n">datenpunkt</span><span class="o">.</span><span class="n">y</span>
    <span class="n">x_mittelwert</span> <span class="o">=</span> <span class="n">x_summe</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">datenpunkte</span><span class="p">)</span> <span class="c1"># Hier den Mittelwert der X-Koordinaten berechnen</span>
    <span class="n">y_mittelwert</span> <span class="o">=</span> <span class="n">y_summe</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">datenpunkte</span><span class="p">)</span> <span class="c1"># Hier den Mittelwert der Y-Koordinaten berechnen</span>

    <span class="k">return</span> <span class="n">Datenpunkt</span><span class="p">(</span><span class="n">x_mittelwert</span><span class="p">,</span> <span class="n">y_mittelwert</span><span class="p">)</span>

<span class="n">run_doctests_mit_lesbarer_ausgabe</span><span class="p">(</span><span class="n">berechne_zentroid_koordinaten</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="a5-aktualisiere-zentroiden">
<span id="loesung5"></span><h2><span class="section-number">22.9.7. </span>A5: <code class="docutils literal notranslate"><span class="pre">aktualisiere_zentroiden()</span></code><a class="headerlink" href="#a5-aktualisiere-zentroiden" title="Link to this heading">#</a></h2>
<p>Der letzte Schritt: mit Hilfe der vorigen Methode <code class="docutils literal notranslate"><span class="pre">berechne_zentroid_koordinaten()</span></code> kannst du nun f√ºr alle Cluster die Zentroiden neu berechnen lassen. <code class="docutils literal notranslate"><span class="pre">aktualisiere_zentroiden()</span></code> erh√§lt dabei eine Liste der Clusters. Ein Eintrag in der Liste ist dabei wiederum eine Liste von Datenpunkte. Unten siehst du ein Beispiel, wie man die einzelnen Cluster abarbeiten kann.</p>
<p>Ein Beispiel:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cluster</span> <span class="o">=</span> <span class="p">[</span>
    <span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="n">Datenpunkt</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">Datenpunkt</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span>
    <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="n">Datenpunkt</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">Datenpunkt</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)],</span>
    <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="n">Datenpunkt</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">)]</span>
<span class="p">]</span>

<span class="c1"># Jeder Cluster ist eine Liste von Datenpunkten</span>
<span class="k">for</span> <span class="n">cluster_datenpunkte</span> <span class="ow">in</span> <span class="n">cluster</span>
    <span class="c1"># Stelle Berechnungen an f√ºr die Datenpunkte eines Clusters</span>
    <span class="o">...</span>
</pre></div>
</div>
<div class="admonition-wichtiger-tipp admonition">
<p class="admonition-title">Wichtiger Tipp</p>
<p>Du ben√∂tigst die Methode <code class="docutils literal notranslate"><span class="pre">berechne_zentroid_koordinaten()</span></code> aus der vorigen Aufgabe!</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">aktualisiere_zentroiden</span><span class="p">(</span><span class="n">cluster</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Datenpunkt</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Datenpunkt</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Aktualisiert die Zentroiden basierend auf den zugewiesenen Datenpunkten.</span>
<span class="sd">    Dabei wird f√ºr jeden Cluster der Zentroid neu berechnet.</span>
<span class="sd">    Args:</span>
<span class="sd">        cluster: Liste mit den Clustern und den zugeh√∂rigen Datenpunkten.</span>
<span class="sd">    Returns:</span>
<span class="sd">        list[Datenpunkt]: Liste der neuen Zentroiden.</span>
<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; cluster = [[Datenpunkt(1.0, 1.0), Datenpunkt(3.0, 3.0)], [Datenpunkt(5.0, 5.0), Datenpunkt(7.0, 7.0)]]</span>
<span class="sd">        &gt;&gt;&gt; aktualisiere_zentroiden(cluster)</span>
<span class="sd">        [Datenpunkt(2.0, 2.0), Datenpunkt(6.0, 6.0)]</span>

<span class="sd">        &gt;&gt;&gt; cluster = [[Datenpunkt(1.4, 4.5), Datenpunkt(5.2, 8.3), Datenpunkt(3.1, 9.2)], [Datenpunkt(1.6, 4.7), Datenpunkt(5.1, 8.2), Datenpunkt(3.1, 9.2)]]</span>
<span class="sd">        &gt;&gt;&gt; aktualisiere_zentroiden(cluster)</span>
<span class="sd">        [Datenpunkt(3.23, 7.33), Datenpunkt(3.27, 7.37)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="o">...</span>  <span class="c1"># Hier L√∂sung erg√§nzen</span>
    <span class="n">neue_zentroiden</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Datenpunkt</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Jeder Cluster ist eine Liste von Datenpunkten</span>
    <span class="k">for</span> <span class="n">datenpunkte_in_cluster</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">:</span>
        <span class="n">neuer_zentroid</span><span class="p">:</span> <span class="n">Datenpunkt</span> <span class="o">=</span> <span class="n">berechne_zentroid_koordinaten</span><span class="p">(</span><span class="n">datenpunkte_in_cluster</span><span class="p">)</span>
        <span class="n">neue_zentroiden</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neuer_zentroid</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">neue_zentroiden</span>

<span class="n">run_doctests_mit_lesbarer_ausgabe</span><span class="p">(</span><span class="n">aktualisiere_zentroiden</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="finale-k-means">
<span id="k-means-final"></span><h2><span class="section-number">22.9.8. </span>Finale: <code class="docutils literal notranslate"><span class="pre">k_means()</span></code><a class="headerlink" href="#finale-k-means" title="Link to this heading">#</a></h2>
<p>Wir haben nun alle n√∂tigen Untermethoden f√ºr den Algorithmus erzeugt und k√∂nnen ihn nun starten. Wir definieren noch eine Methode, um die einzelnen Schritte in Schaubildern (Plots) erzeugen zu k√∂nnen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="k">def</span><span class="w"> </span><span class="nf">plot_cluster</span><span class="p">(</span><span class="n">clusters</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Datenpunkt</span><span class="p">]],</span> <span class="n">zentroiden</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Datenpunkt</span><span class="p">],</span> <span class="n">iteration</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">farben</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="s1">&#39;orange&#39;</span><span class="p">,</span> <span class="s1">&#39;purple&#39;</span><span class="p">,</span> <span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="s1">&#39;brown&#39;</span><span class="p">,</span> <span class="s1">&#39;pink&#39;</span><span class="p">,</span> <span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="s1">&#39;cyan&#39;</span><span class="p">,</span> <span class="s1">&#39;magenta&#39;</span><span class="p">]</span>
    
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="n">cluster_index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">cluster_datenpunkte</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
        <span class="n">x_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">datenpunkt</span><span class="o">.</span><span class="n">x</span> <span class="k">for</span> <span class="n">datenpunkt</span> <span class="ow">in</span> <span class="n">cluster_datenpunkte</span><span class="p">]</span>
        <span class="n">y_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">datenpunkt</span><span class="o">.</span><span class="n">y</span> <span class="k">for</span> <span class="n">datenpunkt</span> <span class="ow">in</span> <span class="n">cluster_datenpunkte</span><span class="p">]</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x_coords</span><span class="p">,</span> <span class="n">y_coords</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">farben</span><span class="p">[</span><span class="n">cluster_index</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Cluster </span><span class="si">{</span><span class="n">cluster_index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s1"> (</span><span class="si">{</span><span class="n">zentroiden</span><span class="p">[</span><span class="n">cluster_index</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">zentroiden</span><span class="p">[</span><span class="n">cluster_index</span><span class="p">]</span><span class="o">.</span><span class="n">y</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>
        <span class="n">cluster_index</span> <span class="o">+=</span> <span class="mi">1</span>
        
    <span class="n">zentroid_x_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">zentroid</span><span class="o">.</span><span class="n">x</span> <span class="k">for</span> <span class="n">zentroid</span> <span class="ow">in</span> <span class="n">zentroiden</span><span class="p">]</span>
    <span class="n">zentroid_y_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">zentroid</span><span class="o">.</span><span class="n">y</span> <span class="k">for</span> <span class="n">zentroid</span> <span class="ow">in</span> <span class="n">zentroiden</span><span class="p">]</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">zentroid_x_coords</span><span class="p">,</span> <span class="n">zentroid_y_coords</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>  <span class="c1"># Zentroiden ohne Legende</span>
    
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;k-means Clustering - Iteration </span><span class="si">{</span><span class="n">iteration</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;X-Koordinate&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Y-Koordinate&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p><strong>Finale:</strong>  Wir haben alle n√∂tigen Methoden und Untermethoden erzeugt, nun k√∂nnen wir die Methoden in unserer <code class="docutils literal notranslate"><span class="pre">k-means()</span></code>-Methode verwenden. In den docstrings findest du auch noch mal den Ablauf der Schritte. Wenn du die Zelle ausf√ºhrst, werden die Berechnungen angestellt und die Plots gedruckt. Am Ende werden dir noch die Cluster und die Zentroiden in Textform ausgegeben.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">k_means</span><span class="p">(</span><span class="n">datenpunkte</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Datenpunkt</span><span class="p">],</span> <span class="n">anzahl_cluster</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">max_iterationen</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">print_plots</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Datenpunkt</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">Datenpunkt</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Hauptfunktion f√ºr den k-means Algorithmus zur Clusterbildung. Der Algorithmus besteht aus folgenden Schritten:</span>
<span class="sd">    2. Initialisierung der Zentroiden</span>
<span class="sd">    3. Zuweisung der Datenpunkte und Bildung der Cluster</span>
<span class="sd">    4. Aktualisierung der Zentroiden</span>
<span class="sd">    5. √úberpr√ºfung, ob sich die Zentroiden ver√§ndert haben</span>
<span class="sd">    Args:</span>
<span class="sd">        datenpunkte: Liste der Datenpunkte, die geclustert werden sollen.</span>
<span class="sd">        anzahl_cluster: Anzahl der Cluster, die gebildet werden sollen.</span>
<span class="sd">        max_iterationen: Maximale Anzahl der Iterationen, die der Algorithmus durchf√ºhrt.</span>
<span class="sd">        print_plots: Gibt an, ob die Cluster in jedem Schritt visualisiert werden</span>
<span class="sd">    Returns:</span>
<span class="sd">        tuple[list[list[Datenpunkt]], list[Datenpunkt]]: Die Cluster und die finalen Zentroiden.</span>
<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; datenpunkte = [Datenpunkt(1.0, 1.0), Datenpunkt(1.0, 3.0), Datenpunkt(3.0, 3.0), Datenpunkt(4.0, 2.0), Datenpunkt(5.0, 5.0)]</span>
<span class="sd">        &gt;&gt;&gt; clusters, zentroiden = k_means(datenpunkte, 2, 100)</span>
<span class="sd">        &gt;&gt;&gt; len(clusters)</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; len(zentroiden)</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; sum(len(cluster) for cluster in clusters) == len(datenpunkte)</span>
<span class="sd">        True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># 1. Initialisierung der Zentroiden</span>
    <span class="n">zentroiden</span> <span class="o">=</span> <span class="n">initialisiere_zentroiden</span><span class="p">(</span><span class="n">datenpunkte</span><span class="p">,</span> <span class="n">anzahl_cluster</span><span class="p">)</span>
    <span class="n">cluster</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iterationen</span><span class="p">):</span>
        <span class="c1"># 2. Cluster berechnen</span>
        <span class="n">cluster</span> <span class="o">=</span> <span class="n">datenpunkte_zuweisen</span><span class="p">(</span><span class="n">datenpunkte</span><span class="p">,</span> <span class="n">zentroiden</span><span class="p">)</span>
        
        <span class="c1"># Plot der Cluster ausgeben, wenn gew√ºnscht</span>
        <span class="k">if</span> <span class="n">print_plots</span><span class="p">:</span>
            <span class="n">plot_cluster</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">zentroiden</span><span class="p">,</span> <span class="n">iteration</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="c1"># 3. Zentroiden aktualisieren</span>
        <span class="n">neue_zentroiden</span> <span class="o">=</span> <span class="n">aktualisiere_zentroiden</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
        
        <span class="c1"># 4. Abbruch wenn die Zentroiden sich nicht ver√§ndert haben</span>
        <span class="k">if</span> <span class="n">neue_zentroiden</span> <span class="o">==</span> <span class="n">zentroiden</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Zentroiden haben sich nicht mehr ver√§ndert. Algorithmus stoppt.&quot;</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="n">zentroiden</span> <span class="o">=</span> <span class="n">neue_zentroiden</span>
    <span class="k">return</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">zentroiden</span>

<span class="c1"># Unit Test f√ºr die Hauptfunktion</span>
<span class="n">run_doctests_mit_lesbarer_ausgabe</span><span class="p">(</span><span class="n">k_means</span><span class="p">)</span>

<span class="c1"># Manueller Start des k-means Algorithmus</span>
<span class="n">datenpunkte</span> <span class="o">=</span> <span class="n">generiere_datenpunkte</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="n">zahlenraum</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">cluster</span><span class="p">,</span> <span class="n">zentroiden</span> <span class="o">=</span> <span class="n">k_means</span><span class="p">(</span><span class="n">datenpunkte</span><span class="o">=</span><span class="n">datenpunkte</span><span class="p">,</span> <span class="n">anzahl_cluster</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">max_iterationen</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">print_plots</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cluster: </span><span class="si">{</span><span class="n">cluster</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Zentroiden: </span><span class="si">{</span><span class="n">zentroiden</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>

        <script type="text/x-thebe-config">
        {
            "rootPath": "..",
            "requestKernel": true,
            "useJupyterLite": true,
            "useBinder": false,
            "kernelOptions": {
                "path": "/"
            },
            "codeMirrorConfig": {
                "theme": "default",
                "mode": "python"
            },
            "mountRestartButton": false,
            "mountRestartallButton": false
        }
        </script>
        <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="kmeansclustering2_aufgabe.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">zur√ºck</p>
        <p class="prev-next-title"><span class="section-number">22.8. </span>Programmierung des Algorithmus</p>
      </div>
    </a>
    <a class="right-next"
       href="entscheidungsbaumlernen.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">weiter</p>
        <p class="prev-next-title"><span class="section-number">23. </span>Entscheidungsb√§ume lernen</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Inhalt
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pseudocode">22.9.1. Pseudocode</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#vorentlastungen">22.9.2. Vorentlastungen</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#unit-tests">22.9.2.1. Unit Tests</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#datenpunkt-klasse">22.9.2.2. <code class="docutils literal notranslate"><span class="pre">Datenpunkt</span></code>-Klasse</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#generiere-datenpunkte">22.9.2.3. <code class="docutils literal notranslate"><span class="pre">generiere_datenpunkte()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#initialisiere-zentroiden">22.9.2.4. <code class="docutils literal notranslate"><span class="pre">initialisiere_zentroiden()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a1-berechne-euklidische-distanz">22.9.3. A1: <code class="docutils literal notranslate"><span class="pre">berechne_euklidische_distanz()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a2-finde-naechsten-zentroiden">22.9.4. A2: <code class="docutils literal notranslate"><span class="pre">finde_naechsten_zentroiden()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a3-datenpunkte-zuweisen">22.9.5. A3: <code class="docutils literal notranslate"><span class="pre">datenpunkte_zuweisen()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a4-berechne-zentroid-koordinaten">22.9.6. A4: <code class="docutils literal notranslate"><span class="pre">berechne_zentroid_koordinaten()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a5-aktualisiere-zentroiden">22.9.7. A5: <code class="docutils literal notranslate"><span class="pre">aktualisiere_zentroiden()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#finale-k-means">22.9.8. Finale: <code class="docutils literal notranslate"><span class="pre">k_means()</span></code></a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
Durch Michael Brenner
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      ¬© Copyright 2025.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>