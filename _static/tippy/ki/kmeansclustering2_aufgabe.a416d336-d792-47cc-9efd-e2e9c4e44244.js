selector_to_html = {"a[href=\"https://en.wikipedia.org/wiki/Unit_testing\"]": "<p><b>Unit testing</b>, <abbr>a.k.a.</abbr> <b>component</b> or <b>module</b> testing, is a form of software testing by which isolated source code is tested to validate expected behavior.</p>", "a[href^=\"https://en.wikipedia.org/wiki/Unit_testing#\"]": "<p><b>Unit testing</b>, <abbr>a.k.a.</abbr> <b>component</b> or <b>module</b> testing, is a form of software testing by which isolated source code is tested to validate expected behavior.</p>", "a[href=\"#vorentlastungen\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\"><span class=\"section-number\">22.8.2. </span>Vorentlastungen<a class=\"headerlink\" href=\"#vorentlastungen\" title=\"Link to this heading\">#</a></h2><p>Wir werden nun vor der ersten Aufgabe folgende Schritte bereits erledigen:</p>", "a[href=\"#aufgabe3\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\"><span class=\"section-number\">22.8.5. </span>A3: <code class=\"docutils literal notranslate\"><span class=\"pre\">datenpunkte_zuweisen()</span></code><a class=\"headerlink\" href=\"#a3-datenpunkte-zuweisen\" title=\"Link to this heading\">#</a></h2><p>Nachdem wir den n\u00e4chsten Zentroiden zu einem Datenpunkt berechnen k\u00f6nnen, sind wir nun in der Lage, alle Datenpunkte zu clustern. Mit der Methode <code class=\"docutils literal notranslate\"><span class=\"pre\">datenpunkte_zuweisen()</span></code> k\u00f6nnen wir nun f\u00fcr jeden Datenpunkt den n\u00e4chsten Zentroiden ermitteln und daraus die Cluster bilden.</p><p>In der Methode unten ist bereits das Erzeugen der leeren Cluster erfolgt, darum musst du dich nicht k\u00fcmmern. Was du noch erg\u00e4nzen musst, ist das Ermitteln des n\u00e4chsten Zentroiden zu jedem Datenpunkt. Mit dem erhaltenen Index kannst du dann in der Liste von Clustern jeden den Datenpunkt dem zugeh\u00f6rigen Cluster anh\u00e4ngen.</p>", "a[href=\"#unit-tests\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\"><span class=\"section-number\">22.8.2.1. </span>Unit Tests<a class=\"headerlink\" href=\"#unit-tests\" title=\"Link to this heading\">#</a></h3><p>Wir werden zum Testen unserer Methoden <a class=\"reference external\" href=\"https://en.wikipedia.org/wiki/Unit_testing\">Unit-Tests</a> verwenden. Das sind kleine, automatisierte Tests, die jeweils eine <strong>einzelne</strong> Funktion oder Methode in einem Programm \u00fcberpr\u00fcfen. Sie helfen sicherzustellen, dass jede Komponente des Codes genau das tut, was sie tun soll. Stell dir Unit-Tests wie eine Checkliste vor, die jede Funktion Schritt f\u00fcr Schritt \u00fcberpr\u00fcft, ob sie die erwarteten Ergebnisse liefert.</p><p>Bei den einzelnen Methoden sind bereits jeweils Unit-Tests hinterlegt, sodass sie dir eine Hilfe bei der Implementierung geben. Wenn du die Test-Methoden studierst, siehst du, wie die zu implementierenden Methoden aufgerufen werden.</p>", "a[href=\"#a1-berechne-euklidische-distanz\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\"><span class=\"section-number\">22.8.3. </span>A1: <code class=\"docutils literal notranslate\"><span class=\"pre\">berechne_euklidische_distanz()</span></code><a class=\"headerlink\" href=\"#a1-berechne-euklidische-distanz\" title=\"Link to this heading\">#</a></h2><p>Zum Warmwerden: du brauchst eine Methode, welche dir die Distanz zwischen zwei Datenpunkten berechnet. Wir werden hierf\u00fcr als <a class=\"reference internal\" href=\"ki_allgemein.html#term-Distanzmasze\"><span class=\"xref std std-term\">Distanzma\u00dfe</span></a> die <a class=\"reference internal\" href=\"ki_allgemein.html#term-Euklidische-Distanz\"><span class=\"xref std std-term\">Euklidische Distanz</span></a> verwenden. Die Methode erh\u00e4lt zwei Datenpunkte und gibt die Distanz auf zwei Nachkommastellen gerundet zur\u00fcck. Zum runden ben\u00f6tigst du die Methode <a class=\"reference external\" href=\"https://www.w3schools.com/python/ref_func_round.asp\">round()</a>.</p>", "a[href=\"#a3-datenpunkte-zuweisen\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\"><span class=\"section-number\">22.8.5. </span>A3: <code class=\"docutils literal notranslate\"><span class=\"pre\">datenpunkte_zuweisen()</span></code><a class=\"headerlink\" href=\"#a3-datenpunkte-zuweisen\" title=\"Link to this heading\">#</a></h2><p>Nachdem wir den n\u00e4chsten Zentroiden zu einem Datenpunkt berechnen k\u00f6nnen, sind wir nun in der Lage, alle Datenpunkte zu clustern. Mit der Methode <code class=\"docutils literal notranslate\"><span class=\"pre\">datenpunkte_zuweisen()</span></code> k\u00f6nnen wir nun f\u00fcr jeden Datenpunkt den n\u00e4chsten Zentroiden ermitteln und daraus die Cluster bilden.</p><p>In der Methode unten ist bereits das Erzeugen der leeren Cluster erfolgt, darum musst du dich nicht k\u00fcmmern. Was du noch erg\u00e4nzen musst, ist das Ermitteln des n\u00e4chsten Zentroiden zu jedem Datenpunkt. Mit dem erhaltenen Index kannst du dann in der Liste von Clustern jeden den Datenpunkt dem zugeh\u00f6rigen Cluster anh\u00e4ngen.</p>", "a[href=\"ki_allgemein.html#term-Distanzmasze\"]": "<dt id=\"term-Distanzmasze\">Distanzma\u00dfe</dt><dd><p>Metriken zur Messung der \u00c4hnlichkeit oder Unterschiedlichkeit zwischen <a class=\"reference internal\" href=\"#term-Datenpunkt\"><span class=\"xref std std-term\">Datenpunkten</span></a>. Beispiele: <a class=\"reference internal\" href=\"#term-Euklidische-Distanz\"><span class=\"xref std std-term\">Euklidische Distanz</span></a>, <a class=\"reference internal\" href=\"#term-Manhattan-Distanz\"><span class=\"xref std std-term\">Manhattan-Distanz</span></a>.</p></dd>", "a[href=\"#a5-aktualisiere-zentroiden\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\"><span class=\"section-number\">22.8.7. </span>A5: <code class=\"docutils literal notranslate\"><span class=\"pre\">aktualisiere_zentroiden()</span></code><a class=\"headerlink\" href=\"#a5-aktualisiere-zentroiden\" title=\"Link to this heading\">#</a></h2><p>Der letzte Schritt: mit Hilfe der vorigen Methode <code class=\"docutils literal notranslate\"><span class=\"pre\">berechne_zentroid_koordinaten()</span></code> kannst du nun f\u00fcr alle Cluster die Zentroiden neu berechnen lassen. <code class=\"docutils literal notranslate\"><span class=\"pre\">aktualisiere_zentroiden()</span></code> erh\u00e4lt dabei eine Liste der Clusters. Ein Eintrag in der Liste ist dabei wiederum eine Liste von Datenpunkte. Unten siehst du ein Beispiel, wie man die einzelnen Cluster abarbeiten kann.</p><p>Ein Beispiel:</p>", "a[href=\"ki_allgemein.html#term-Euklidische-Distanz\"]": "<dt id=\"term-Euklidische-Distanz\">Euklidische Distanz</dt><dd><p>Eine <a class=\"reference internal\" href=\"#term-Distanzmasze\"><span class=\"xref std std-term\">Distanzmetrik</span></a>, welche die direkte Strecke (Luftlinie) zwischen zwei Punkten misst. Sie wird berechnet, indem man die Differenzen der Koordinaten quadriert, addiert und daraus die Wurzel zieht. Beispiel: Die Euklidische Distanz zwischen den Punkten (1, 2) und (4, 6) betr\u00e4gt <span class=\"math notranslate nohighlight\">\\(\\sqrt{(1-4)^2 + (2-6)^2} = \\sqrt{9 + 16} = 5\\)</span>.</p></dd>", "a[href=\"#programmierung-des-algorithmus\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\"><span class=\"section-number\">22.8. </span>Programmierung des Algorithmus<a class=\"headerlink\" href=\"#programmierung-des-algorithmus\" title=\"Link to this heading\">#</a></h1><p>Wir werden uns nun Schritt f\u00fcr Schritt die n\u00f6tigen Methoden den k-Means-Clustering Algorithmus erarbeiten. Um am Ende nicht einen gro\u00dfen Codeblock erstellen zu m\u00fcssen, werden wir soviel Vorarbeit wie m\u00f6glich erledigen. So kannst du dich am Ende ganz auf die Implementierung der Teile des Algorithmus konzentrieren [Stichwort: externe kognitive Belastung gering halten, siehe <a class=\"reference external\" href=\"https://de.wikipedia.org/wiki/Cognitive_Load_Theory\">Cognitive Load Theory (CLT)</a> \ud83d\ude09]</p>", "a[href=\"#a4-berechne-zentroid-koordinaten\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\"><span class=\"section-number\">22.8.6. </span>A4: <code class=\"docutils literal notranslate\"><span class=\"pre\">berechne_zentroid_koordinaten()</span></code><a class=\"headerlink\" href=\"#a4-berechne-zentroid-koordinaten\" title=\"Link to this heading\">#</a></h2><p>Wir ben\u00f6tigen nun zum einen noch eine Funktion <code class=\"docutils literal notranslate\"><span class=\"pre\">berechne_zentroid_koordinaten()</span></code>, welche uns aus den Datenpunkten eines Clusters die neuen Koordinaten des Zentroiden berechnet. Diese Funktion wird dann von <code class=\"docutils literal notranslate\"><span class=\"pre\">aktualisiere_zentroiden()</span></code> in der n\u00e4chsten Aufgabe verwendet, um die Zentroiden in jeder Iteration alle neu zu berechnen.</p>", "a[href=\"#aufgabe4\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\"><span class=\"section-number\">22.8.6. </span>A4: <code class=\"docutils literal notranslate\"><span class=\"pre\">berechne_zentroid_koordinaten()</span></code><a class=\"headerlink\" href=\"#a4-berechne-zentroid-koordinaten\" title=\"Link to this heading\">#</a></h2><p>Wir ben\u00f6tigen nun zum einen noch eine Funktion <code class=\"docutils literal notranslate\"><span class=\"pre\">berechne_zentroid_koordinaten()</span></code>, welche uns aus den Datenpunkten eines Clusters die neuen Koordinaten des Zentroiden berechnet. Diese Funktion wird dann von <code class=\"docutils literal notranslate\"><span class=\"pre\">aktualisiere_zentroiden()</span></code> in der n\u00e4chsten Aufgabe verwendet, um die Zentroiden in jeder Iteration alle neu zu berechnen.</p>", "a[href=\"#aufgabe5\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\"><span class=\"section-number\">22.8.7. </span>A5: <code class=\"docutils literal notranslate\"><span class=\"pre\">aktualisiere_zentroiden()</span></code><a class=\"headerlink\" href=\"#a5-aktualisiere-zentroiden\" title=\"Link to this heading\">#</a></h2><p>Der letzte Schritt: mit Hilfe der vorigen Methode <code class=\"docutils literal notranslate\"><span class=\"pre\">berechne_zentroid_koordinaten()</span></code> kannst du nun f\u00fcr alle Cluster die Zentroiden neu berechnen lassen. <code class=\"docutils literal notranslate\"><span class=\"pre\">aktualisiere_zentroiden()</span></code> erh\u00e4lt dabei eine Liste der Clusters. Ein Eintrag in der Liste ist dabei wiederum eine Liste von Datenpunkte. Unten siehst du ein Beispiel, wie man die einzelnen Cluster abarbeiten kann.</p><p>Ein Beispiel:</p>", "a[href=\"#aufgabe2\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\"><span class=\"section-number\">22.8.4. </span>A2: <code class=\"docutils literal notranslate\"><span class=\"pre\">finde_naechsten_zentroiden()</span></code><a class=\"headerlink\" href=\"#a2-finde-naechsten-zentroiden\" title=\"Link to this heading\">#</a></h2><p>Nun wollen wir f\u00fcr einen <code class=\"docutils literal notranslate\"><span class=\"pre\">Datenpunkt</span></code> den n\u00e4chstgelegenen Zentroiden ermitteln. Wir bekommen daf\u00fcr die Liste von Zentroiden \u00fcbergeben und m\u00fcssen hieraus nun den Zentroiden ermitteln, zu dem die Distanz des <code class=\"docutils literal notranslate\"><span class=\"pre\">Datenpunkts</span></code> am geringsten ist. \u00dcberlege dir vorher, wie du vorgehen m\u00f6chtest. Zur\u00fcckgegeben wird der Index des ermittelten Zentroiden. Wenn also der 3. Zentroid der n\u00e4chstgelegene ist, dann muss der Index 2 zur\u00fcckgegeben wird (da Index bei 0 beginnt).</p>", "a[href=\"kmeansclustering.html#ablauf-k-means-algorithmus\"]": "<div class=\"admonition important\" id=\"ablauf-k-means-algorithmus\">\n<p class=\"admonition-title\">Wichtig</p>\n<p><strong>Auswahl der Anzahl der Cluster (<span class=\"math notranslate nohighlight\">\\(k\\)</span>)</strong><br/>\nBevor der Algorithmus gestartet werden, muss die <strong>Anzahl der Cluster</strong> <span class=\"math notranslate nohighlight\">\\(k\\)</span> festgelegt werden. Diese Zahl bestimmt, in wie viele Gruppen die Datenpunkte aufgeteilt werden sollen.</p>\n<p><strong>1. Initialisierung der Zentroiden</strong><br/>\nAls n\u00e4chstes werden <span class=\"math notranslate nohighlight\">\\(k\\)</span> Datenpunkte aus den Daten oder <span class=\"math notranslate nohighlight\">\\(k\\)</span> zuf\u00e4llige Punkte ausgew\u00e4hlt, um die anf\u00e4nglichen <strong>Zentroiden</strong> (Cluster-Zentren) zu bestimmen.</p>\n<p><strong>2. Zuweisung der Datenpunkte und Bildung der Cluster</strong><br/>\nJeder Datenpunkt wird dem n\u00e4chstgelegenen Zentroiden zugewiesen. Dies wird durch die <a class=\"reference internal\" href=\"ki_allgemein.html#term-Distanzmasze\"><span class=\"xref std std-term\">Distanzma\u00dfe</span></a> zu allen Zentroiden bestimmt (z.B. mittels <a class=\"reference internal\" href=\"ki_allgemein.html#term-Euklidische-Distanz\"><span class=\"xref std std-term\">Euklidischer Distanz</span></a> oder <a class=\"reference internal\" href=\"ki_allgemein.html#term-Manhattan-Distanz\"><span class=\"xref std std-term\">Manhattan-Distanz</span></a>).</p>\n<p><strong>3. Aktualisierung der Zentroiden</strong><br/>\nDie Zentroiden werden neu berechnet, indem der Durchschnitt (<strong>Mean</strong>) aller Punkte innerhalb eines Clusters berechnet wird.</p>\n<p><strong>4. Wiederholung der Schritte 3 und 4</strong><br/>\nDie Schritte 2 und 3 werden solange wiederholt, bis sich die Zentroiden nicht mehr \u00e4ndern oder eine maximale Anzahl an Iterationen erreicht ist.</p>\n</div>", "a[href=\"#finale-k-means\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\"><span class=\"section-number\">22.8.8. </span>Finale: <code class=\"docutils literal notranslate\"><span class=\"pre\">k_means()</span></code><a class=\"headerlink\" href=\"#finale-k-means\" title=\"Link to this heading\">#</a></h2><p>Wir haben nun alle n\u00f6tigen Untermethoden f\u00fcr den Algorithmus erzeugt und k\u00f6nnen ihn nun starten. Wir definieren noch eine Methode, um die einzelnen Schritte in Schaubildern (Plots) erzeugen zu k\u00f6nnen.</p>", "a[href=\"#pseudocode\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\"><span class=\"section-number\">22.8.1. </span>Pseudocode<a class=\"headerlink\" href=\"#pseudocode\" title=\"Link to this heading\">#</a></h2><p>Nochmals die Grundidee des <a class=\"reference internal\" href=\"kmeansclustering.html#ablauf-k-means-algorithmus\"><span class=\"std std-ref\">Algorithmus</span></a>:</p>", "a[href=\"kmeansclustering2_loesung.html#k-means-final\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\"><span class=\"section-number\">22.9.8. </span>Finale: <code class=\"docutils literal notranslate\"><span class=\"pre\">k_means()</span></code><a class=\"headerlink\" href=\"#finale-k-means\" title=\"Link to this heading\">#</a></h2><p>Wir haben nun alle n\u00f6tigen Untermethoden f\u00fcr den Algorithmus erzeugt und k\u00f6nnen ihn nun starten. Wir definieren noch eine Methode, um die einzelnen Schritte in Schaubildern (Plots) erzeugen zu k\u00f6nnen.</p>", "a[href=\"#generiere-datenpunkte\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\"><span class=\"section-number\">22.8.2.3. </span><code class=\"docutils literal notranslate\"><span class=\"pre\">generiere_datenpunkte()</span></code><a class=\"headerlink\" href=\"#generiere-datenpunkte\" title=\"Link to this heading\">#</a></h3><p>Wir ben\u00f6tigen automatische Eingabedaten und wir m\u00f6chten unsere <code class=\"docutils literal notranslate\"><span class=\"pre\">kmeans()</span></code>-Methode mit beliebig gro\u00dfen Datens\u00e4tzen testen k\u00f6nnen. Daf\u00fcr werden wir Methode <code class=\"docutils literal notranslate\"><span class=\"pre\">generiere_datenpunkte()</span></code> verwenden. Dieser k\u00f6nnen wir die Anzahl der gew\u00fcnschten Datenpunkte und den gew\u00fcnschten Zahlenraum angeben. Wir erhalten eine Liste von <code class=\"docutils literal notranslate\"><span class=\"pre\">Datenpunkten</span></code> zur\u00fcck.</p>", "a[href=\"#aufgabe1\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\"><span class=\"section-number\">22.8.3. </span>A1: <code class=\"docutils literal notranslate\"><span class=\"pre\">berechne_euklidische_distanz()</span></code><a class=\"headerlink\" href=\"#a1-berechne-euklidische-distanz\" title=\"Link to this heading\">#</a></h2><p>Zum Warmwerden: du brauchst eine Methode, welche dir die Distanz zwischen zwei Datenpunkten berechnet. Wir werden hierf\u00fcr als <a class=\"reference internal\" href=\"ki_allgemein.html#term-Distanzmasze\"><span class=\"xref std std-term\">Distanzma\u00dfe</span></a> die <a class=\"reference internal\" href=\"ki_allgemein.html#term-Euklidische-Distanz\"><span class=\"xref std std-term\">Euklidische Distanz</span></a> verwenden. Die Methode erh\u00e4lt zwei Datenpunkte und gibt die Distanz auf zwei Nachkommastellen gerundet zur\u00fcck. Zum runden ben\u00f6tigst du die Methode <a class=\"reference external\" href=\"https://www.w3schools.com/python/ref_func_round.asp\">round()</a>.</p>", "a[href=\"#initialisiere-zentroiden\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\"><span class=\"section-number\">22.8.2.4. </span><code class=\"docutils literal notranslate\"><span class=\"pre\">initialisiere_zentroiden()</span></code><a class=\"headerlink\" href=\"#initialisiere-zentroiden\" title=\"Link to this heading\">#</a></h3><p>Im ersten Schritt des k-means Algorithmus werden die Startzentroiden bestimmt. Die Methode <code class=\"docutils literal notranslate\"><span class=\"pre\">initialisiere_zentroiden()</span></code> w\u00e4hlt aus der \u00fcbergebenen Liste von <code class=\"docutils literal notranslate\"><span class=\"pre\">Datenpunkten</span></code> die gew\u00fcnschte Anzahl der Zentroiden zuf\u00e4llig aus. Die Auswahl ist zwar <strong>zuf\u00e4llig</strong>, bleibt <strong>aber reproduzierbar</strong>, weil wir in der Methode <code class=\"docutils literal notranslate\"><span class=\"pre\">generiere_datenpunkte</span></code> den Zufallsgenerator auf einen fixen Wert gesetzt haben. Die Methode gibt eine Liste von <code class=\"docutils literal notranslate\"><span class=\"pre\">Datenpunkten</span></code> zur\u00fcck.</p>", "a[href=\"#datenpunkt-klasse\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\"><span class=\"section-number\">22.8.2.2. </span><code class=\"docutils literal notranslate\"><span class=\"pre\">Datenpunkt</span></code>-Klasse<a class=\"headerlink\" href=\"#datenpunkt-klasse\" title=\"Link to this heading\">#</a></h3><p>Damit du die Koordinaten der Datenpunkte und der Zentroiden bequem veralten k\u00f6nnen, ist die Hilfsklasse <code class=\"docutils literal notranslate\"><span class=\"pre\">Datenpunkt</span></code> bereits vorhanden. In dieser Klasse erweitern wir noch die internen Methoden <code class=\"docutils literal notranslate\"><span class=\"pre\">__eq__()</span></code> und <code class=\"docutils literal notranslate\"><span class=\"pre\">__hash__()</span></code>, damit wir es sp\u00e4ter leichter haben, die neuen Zentroiden mit den alten Zentroiden der vorigen Iteration zu vergleichen (siehe Schritt 4 des <a class=\"reference internal\" href=\"kmeansclustering.html#ablauf-k-means-algorithmus\"><span class=\"std std-ref\">Algorithmus</span></a>). Es w\u00e4re auch m\u00f6glich, die Koordinaten in verschachtelten Arrays zu verwalten, aber die L\u00f6sung einer eigenen Klasse ist eleganter und wir k\u00f6nnen Komplexit\u00e4t in diese Klasse auslagern. F\u00fcr dich wichtig zu wissen: einen neuen Datenpunkt kannst du mit <code class=\"docutils literal notranslate\"><span class=\"pre\">punkt</span> <span class=\"pre\">=</span> <span class=\"pre\">Datenpunkt(1.2345,</span> <span class=\"pre\">6.789)</span></code> erzeugen.</p>", "a[href=\"#a2-finde-naechsten-zentroiden\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\"><span class=\"section-number\">22.8.4. </span>A2: <code class=\"docutils literal notranslate\"><span class=\"pre\">finde_naechsten_zentroiden()</span></code><a class=\"headerlink\" href=\"#a2-finde-naechsten-zentroiden\" title=\"Link to this heading\">#</a></h2><p>Nun wollen wir f\u00fcr einen <code class=\"docutils literal notranslate\"><span class=\"pre\">Datenpunkt</span></code> den n\u00e4chstgelegenen Zentroiden ermitteln. Wir bekommen daf\u00fcr die Liste von Zentroiden \u00fcbergeben und m\u00fcssen hieraus nun den Zentroiden ermitteln, zu dem die Distanz des <code class=\"docutils literal notranslate\"><span class=\"pre\">Datenpunkts</span></code> am geringsten ist. \u00dcberlege dir vorher, wie du vorgehen m\u00f6chtest. Zur\u00fcckgegeben wird der Index des ermittelten Zentroiden. Wenn also der 3. Zentroid der n\u00e4chstgelegene ist, dann muss der Index 2 zur\u00fcckgegeben wird (da Index bei 0 beginnt).</p>"}
skip_classes = ["headerlink", "sd-stretched-link"]

window.onload = function () {
    for (const [select, tip_html] of Object.entries(selector_to_html)) {
        const links = document.querySelectorAll(`article.bd-article ${select}`);
        for (const link of links) {
            if (skip_classes.some(c => link.classList.contains(c))) {
                continue;
            }
            link.classList.add('has-tippy');
            tippy(link, {
                content: tip_html,
                allowHTML: true,
                arrow: false,
                placement: 'auto-start', maxWidth: 500, interactive: true, boundary: document.body, appendTo: document.body,
                onShow(instance) {MathJax.typesetPromise([instance.popper]).then(() => {var isFirefox=typeof InstallTrigger!=='undefined';if(isFirefox&&window.MathJax&&MathJax.startup&&MathJax.startup.output&&MathJax.startup.output.name==="SVG"){const svgs=instance.popper.querySelectorAll('svg');svgs.forEach(svg=>{let bbox=svg.getBBox(),x=bbox.x,y=bbox.y,width=bbox.width,height=bbox.height;svg.setAttribute('width',width);svg.setAttribute('height',height);svg.setAttribute('viewBox',`${x} ${y} ${width} ${height}`);});let rescale=0.015;svgs.forEach(svg=>{let bbox=svg.getBBox(),width=bbox.width,height=bbox.height;svg.setAttribute('width',width*rescale);svg.setAttribute('height',height*rescale);});}});},
            });
        };
    };
    console.log("tippy tips loaded!");
};
